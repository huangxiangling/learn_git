根据上述自己对于 1 和 2 的演示，写一段对于不同 GC 和堆内存的总结，提交到 GitHub。

1.GC策略分为串行GC、并行GC、并发GC;
2.常用的GC包含:
  (1).串行GC（Serial GC）
  (2).并行GC（Parallel GC）
  (3).CMS GC（ConcMarkSweep GC,并发GC）
  (4).G1 GC（Garbage First，意为垃圾优先）
  (5).ZGC/Shenandoah GC

使用不同GC策略的总结：使用不同的GC策略能达到不同的GC垃圾回收效果
	  当使用串行GC（Serial GC），垃圾回收使用单线程收集器，会触发STW GC暂停，GC暂停期间，所有CPU内核线程执行垃圾回收，这样的效率非常低。
	  java8默认使用并行GC（Parallel GC），所有CPU内核都是并行在执行垃圾回收，并行GC也会触发STW GC暂停，相比串行GC，并行GC大大提高了CPU的使用，垃圾回收效率也提高了。
	  CMS GC是java9以后使用的GC策略，其中最大的改动点是对老年代标记-清除阶段，垃圾回收线程和业务线程可以并发的执行，相比之前的标记-清除-整理算法的改进，CMS GC将不对垃圾碎片进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收。
	  java11默认使用G1 GC垃圾回收，其回收策略较以往的串行、并行和CMS GC有很大的改变，它将堆内存划分为颗粒度更小的多个块（通常是2048个），每个块可能一会定义成Eden区，一会是young区或old区，只要是满足G1设置的特定回收指标，就会触发垃圾回收。
	  ZGC/Shenandoah 是通过着色指针和读屏障，实现几乎全部的并发执行，几毫级别的延迟，线性可扩展。
	  
改变堆内存参数直接影响young GC和old GC回收次数及GC 暂停时间：
      一般情况下，-Xmx最大堆内存和-Xms初始化堆内存大小的值应该设置为一样，否则堆内存扩容可能会导致性能抖动。
      -Xmx最大堆内存直接影响着young GC和old GC的回收次数及性能：合理的配置堆内存参数将大大提高系统性能
	      当-Xmx足够大时，在一定时间内，发生young GC的次数很少，发生old GC的次数可能为0或只有一两次。但是这种情况的弊端就是，old区容量越大，GC暂停的时间就越长。
          当-Xmx较小时，在一定时间内，发生的young GC和old GC的次数就会相对较多，如果-Xmx很小，则很有可能会导致内存溢出的风险。
      -Xms初始化堆内存的大小，一般设置和-Xmx一样大以防止堆内存扩容导致的性能抖动。
      结合以上不同的GC策略，也是会直接影响垃圾回收的性能。		  
	  
	
 